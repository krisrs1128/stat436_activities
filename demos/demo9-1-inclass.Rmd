---
title: "Untitled"
output: html_document
date: "`r Sys.Date()`"
---

```{r, echo = FALSE}
knitr::opts_chunk$set(warnings = FALSE, message = FALSE)
```

```{r}
library(tidyverse)
th <- theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c"),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    strip.text = element_text(size = 16),
    legend.position = "bottom"
  )
theme_set(th)
```

1. [Polio Clustering] The polio dataset contains weekly counts of new polio
cases across each state in the United States, starting as early as 1912. In this
question, our goal is to apply $K$-means to group states with similar incidence
patterns.

```{r}
polio <- read_csv("https://uwmadison.box.com/shared/static/nm7yku4y9q7ylvz5kbxya3ouj2njd0x6.csv")
head(polio)

polio
```

a. Is it necessary to reshape the data before it can be used in the
`kmeans` function? If so, provide the code. If not, provide a brief
explanation.

```{r}
xy_data <- polio |>
    mutate(x = as.numeric(period_start_date), y = log1p(cases)) |>
    select(x, y) |>
    scale() |>
    as_tibble()
fit <- kmeans(as.matrix(xy_data), centers = 5)
ggplot(augment(fit, xy_data)) +
    geom_point(aes(x, y, col = .cluster))
```

```{r}
x <- polio |>
    pivot_wider(names_from = period_start_date, values_from = cases, values_fill = 0)
```

b. Let `x` contain the output from part (a). Compare the three
approaches to $K$-means in the code block below. Which would you recommend
using? Justify your choice.

  Option 1:
```{r, eval = FALSE}
x |>
  select(-state) |>
  kmeans(centers = 5)
```

  Option 2:

```{r, eval = FALSE}
x |>
  select(-state) |>
  scale() |>
  kmeans(centers = 5)
```

    Option 3:

```{r, eval = FALSE}
fit <- x |>
  select(-state) |>
  t() |>
  scale() |>
  t() |>
  kmeans(centers = 5, nstart = 10)
```

c. Provide code needed for extracting and visualizing centroids
from the $K$-means fit made in part (b). Draw a rough sketch of the expected
result and include annotations that would help a reader understand the output.

Let's first visualize the cluster centroids.

```{r}
library(tidymodels)
library(lubridate)
memberships <- augment(fit, x)
centroids <- tidy(fit)

# reshape centroids so column names starting with "19***" are an explicit column called "date". Do not modify size, withinss, or cluster.
# The date column should have type date.
# store this in centroids_long
centroids_long <- centroids |>
  pivot_longer(
    cols = matches("^19"),
    names_to = "date",
    values_to = "cases"
  ) |>
  mutate(date = as_date(date))

# Use centroids_long to create a faceted scatterplot (geom_point) with ggplot2.
#    - x -> date, y -> log1p(cases)
#    - facet -> cluster
ggplot(centroids_long, aes(date, log1p(cases))) +
  geom_point() +
  facet_wrap(~ cluster) +
  labs(
    title = "Cluster Centroids",
    x = "Date",
    y = "log1p(Cases)"
  )
```

This groups the raw time series according to their cluster membership.

```{r}
library(scico)
memberships_long <- memberships |>
  pivot_longer(
    cols = matches("^19"),
    names_to = "date",
    values_to = "cases"
  ) |>
  mutate(date = as_date(date))

# create a ggplot2 heatmap of cases over time
# x -> date, y -> state, fill -> cases
# facet_grid -> .cluster
# use scico for fill palette
ggplot(memberships_long, aes(date, reorder(state, cases), fill = log1p(cases), col = log1p(cases))) +
  geom_tile() +
  facet_grid(.cluster ~ ., scale = "free_y", space = "free") +
  scale_fill_scico(palette = "berlin") +
  scale_color_scico(palette = "berlin") +
  labs(
    x = "Date",
    y = "State",
    fill = "log(1 + Cases)",
    color = "log(1 + Cases)"
  )
```